应用名本地化
1、清空PROJECT---Localizations
2、工程目录下创建文件夹，命名为en.lproj
3、添加InfoPlist.strings文件，去除当前引用
4、将InfoPlist.strings放入en.lproj文件内，添加InfoPlist.strings到工程
5、你会发现PROJECT---Localizations下有English语言了，且InfoPlist.strings可以展开、缩放
6、点击加号添加其他语言，展开InfoPlist.strings，有对应项，PROJECT---Localizations下也有对应项
7、为每种语言编写CFBundleDisplayName = "WeiBo";

应用内字符串的本地化
1、添加Localizable.strings文件
2、点击它，点击右边的Localize...
3、选择English，点击Localize
4、点击Localizable.strings，将其他语言勾选上
5、为每种语言编写TestKey = "test";
6、应用内使用NSLocalizedString("TestKey", comment: "")获取字符串


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
重写override func pushViewController(_ viewController: UIViewController, animated: Bool)时应注意的地方：

override func pushViewController(_ viewController: UIViewController, animated: Bool) {
if viewControllers.count > 0 {
viewController.hidesBottomBarWhenPushed = true
}
super.pushViewController(viewController, animated: animated)
}

hidesBottomBarWhenPushed的设置一定放在pushViewController之前


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
CocoaPods 0.36-beta后增加了对iOS 8框架以及Swift语言所编写的库的支持。使用use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。
这样的话，我们不需要在Bridging文件引入头文件,只需要在Swift文件中import 相应的库,就像我们 import UIKit类似,这种方式支持iOS 8以上的系统.我们只需要支持iOS8以上的系统。


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
UIViewController自己来定制statusBar的前景颜色（黑色或白色）,涉及的接口如下：

- (UIStatusBarStyle)preferredStatusBarStyle;
- (UIViewController *)childViewControllerForStatusBarStyle;
- (void)setNeedsStatusBarAppearanceUpdate

- (UIStatusBarStyle)preferredStatusBarStyle:
在你自己的UIViewController里重写此方法，返回你需要的值(UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent)；
注意：
这里如果你只是简单的return一个固定的值，那么该UIViewController显示的时候，程序就会马上调用该方法，来改变statusBar的前景部分；
如果UIViewController已经显示，你可能还要更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)， 这个和UIView的setNeedsDisplay原理差不多(调用UIView对象的setNeedsDisplay方法后，系统会在下次页面刷新时，调用重绘该view，系统最快能1秒刷新60次页面，具体要看程序设置)。

- (UIViewController *)childViewControllerForStatusBarStyle:
这个接口也很重要，默认返回值为nil。当我们调用setNeedsStatusBarAppearanceUpdate时，系统会调用application.window的rootViewController的preferredStatusBarStyle方法，我们程序里一般都是用UINavigationController做root，如果是这种情况，那我们自己的UIViewController里的preferredStatusBarStyle根本不会被调用；这种情况下childViewControllerForStatusBarStyle就派上用场了，我们要子类化一个UINavigationController，在这个子类里面重写childViewControllerForStatusBarStyle方法，如下：

- (UIViewController *)childViewControllerForStatusBarStyle{
return self.topViewController;
}
上面代码的意思就是说，不要调用我自己(就是UINavigationController)的preferredStatusBarStyle方法，而是去调用navigationController.topViewController的preferredStatusBarStyle方法，这样写的话，就能保证当前显示的UIViewController的preferredStatusBarStyle方法能影响statusBar的前景部分。

另外，有时我们的当前显示的UIViewController可能有多个childViewController，重写当前UIViewController的childViewControllerForStatusBarStyle方法，让childViewController的preferredStatusBarStyle生效(当前UIViewController的preferredStatusBarStyle就不会被调用了)。

简单来说，只要UIViewController重写的的childViewControllerForStatusBarStyle方法返回值不是nil，那么，UIViewController的preferredStatusBarStyle方法就不会被系统调用，系统会调用childViewControllerForStatusBarStyle方法返回的UIViewController的preferredStatusBarStyle方法。

- (void)setNeedsStatusBarAppearanceUpdate:
让系统去调用application.window的rootViewController的preferredStatusBarStyle方法,如果rootViewController的childViewControllerForStatusBarStyle返回值不为nil，
则参考上面的讲解。

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
对于导航栏，基类仅仅提供newNavigationBar空的UIView，每个视图控制拥有的导航栏，自己添加;后期如果发现有公共的可以在基类中统一设置；

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
消除系统日志：if we're in the real pre-commit handler we can't actually add any new fences due to CA restriction
in your Xcode:
Click on your active scheme name right next to the Stop button
Click on Edit Scheme....
in Run (Debug)-->select the Arguments tab
in Environment Variables click +
add variable: OS_ACTIVITY_MODE = disable


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
自动布局，水平居中+垂直居中

//添加游客视图上的内容视图
let contentOfVisitorView = ContentOfVisitorView()
contentOfVisitorView.setAllCtlSize(noteText: "欢迎使用博客，写点有意思的东西看，关注你所感兴趣得东西。赶紧注册登录吧！")
//为contentOfVisitorView及其父视图visitorView添加约束
contentOfVisitorView.translatesAutoresizingMaskIntoConstraints = false
visitorView.addSubview(contentOfVisitorView)

let layout_contentOfVisitorView = ["contentOfVisitorView":contentOfVisitorView,"visitorView":visitorView]
let constraintsY = NSLayoutConstraint.constraints(withVisualFormat: "V:|-[contentOfVisitorView]-|", options: NSLayoutFormatOptions.alignAllCenterY, metrics: nil, views: layout_contentOfVisitorView)
let constraintsX = NSLayoutConstraint.constraints(withVisualFormat: "H:|-[contentOfVisitorView]-|", options: NSLayoutFormatOptions.alignAllCenterX, metrics: nil, views: layout_contentOfVisitorView)

visitorView.addConstraints(constraintsX)
visitorView.addConstraints(constraintsY)


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
App Key：1069040971
App Secret：dced87f388fc65cf3eb6861e0614be24
access token:2.002SUK3C_5a2KB590f93dd00DxZ3yD

access_token目前OAuth1.0为永久有效；OAuth2.0对于未审核应用有效期为24小时，对于已审核应用有效期最低为7天，不同的应用级别有效期不同

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
类名.self获取的是实例类型，即OC中的isa(一个类用结构体类型描述自己)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.AnyObject

本身就是一个接口,而且所有的class都隐式的实现了这个接口，这也限制了AnyObject是只适用于Class类型的原因。
AnyObject有什么用呢?
有过Objective-C开发经验的人肯定知道id, 它可以表示任意类的实例, 编译器不会对向声明为 id 的变量进行类型检查.而 Swift为了与 Cocoa 架构进行协作开发，就将原来的id用 AnyObject 来进行替代。

2.Any
既然AnyObject是只适用于Class类型 ，那swift中的所有基本类型怎么办，这个时候呢Any就帮上忙了。Any不仅仅能够容括class类型 ，说得更直白一点, 就是所有的类型都可以用Any表示, 包括基本数据类型, enum, struct, func(方法)等等.

3.AnyClass：
属于AnyObject.Type的别名：typealias AnyClass = AnyObject .Type
表示任意类的元类型，任意类的类型都隐式遵守这个协议.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FIXME: 记录需要修改bug的相关说明
//TODO:  记录待办事项的相关说明
// MARK:- 对下面代码的相关说明,带分割线
// MARK: 对下面代码的相关说明,不带分割线

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
set get这两个针对计算属性
willSet didSet这两个针对存储属性

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
数组的map:通过提供的闭包，闭包中对每一个数组元素进行处理，并返回处理结果；map的的最终结果是处理后的结果集；
数组的filter:通过提供的闭包，闭包中对每一个数组元素进行判断处理，并返回true/false；map的的最终结果是过滤后的结果集；
数组的reduce:通过提供的闭包，闭包中对每一个数组元素进行判断处理，并返回拼接结果；map的的最终结果是拼接的最后结果；
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

OC是通过KVC对属性赋值，通过动态派发调用函数
Swift类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。
添加@objc修饰符并不意味着这个方法或者属性会变成动态派发，Swift依然可能会将其优化为静态调用。如果你需要和Objective-C里动态调用时相同的运行时特性的话，你需要使用的修饰符是dynamic。一般情况下在做App开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 "黑魔法" 的时候，我们就需要用到dynamic修饰符了。
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HttpEngine.httpEngine.getUID { (value, error) in
if error == nil {
guard let dic = value else{
return
}

print(dic)

}else{

}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

























































