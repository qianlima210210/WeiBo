应用名本地化
1、清空PROJECT---Localizations
2、工程目录下创建文件夹，命名为en.lproj
3、添加InfoPlist.strings文件，去除当前引用
4、将InfoPlist.strings放入en.lproj文件内，添加InfoPlist.strings到工程
5、你会发现PROJECT---Localizations下有English语言了，且InfoPlist.strings可以展开、缩放
6、点击加号添加其他语言，展开InfoPlist.strings，有对应项，PROJECT---Localizations下也有对应项
7、为每种语言编写CFBundleDisplayName = "WeiBo";

应用内字符串的本地化
1、添加Localizable.strings文件
2、点击它，点击右边的Localize...
3、选择English，点击Localize
4、点击Localizable.strings，将其他语言勾选上
5、为每种语言编写TestKey = "test";
6、应用内使用NSLocalizedString("TestKey", comment: "")获取字符串


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
重写override func pushViewController(_ viewController: UIViewController, animated: Bool)时应注意的地方：

override func pushViewController(_ viewController: UIViewController, animated: Bool) {
if viewControllers.count > 0 {
viewController.hidesBottomBarWhenPushed = true
}
super.pushViewController(viewController, animated: animated)
}

hidesBottomBarWhenPushed的设置一定放在pushViewController之前


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
CocoaPods 0.36-beta后增加了对iOS 8框架以及Swift语言所编写的库的支持。使用use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。
这样的话，我们不需要在Bridging文件引入头文件,只需要在Swift文件中import 相应的库,就像我们 import UIKit类似,这种方式支持iOS 8以上的系统.我们只需要支持iOS8以上的系统。


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
UIViewController自己来定制statusBar的前景颜色（黑色或白色）,涉及的接口如下：

- (UIStatusBarStyle)preferredStatusBarStyle;
- (UIViewController *)childViewControllerForStatusBarStyle;
- (void)setNeedsStatusBarAppearanceUpdate

- (UIStatusBarStyle)preferredStatusBarStyle:
在你自己的UIViewController里重写此方法，返回你需要的值(UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent)；
注意：
这里如果你只是简单的return一个固定的值，那么该UIViewController显示的时候，程序就会马上调用该方法，来改变statusBar的前景部分；
如果UIViewController已经显示，你可能还要更改statusBar的前景色，那么，你首先需要调用下面的setNeedsStatusBarAppearanceUpdate方法(这个方法会通知系统去调用当前UIViewController的preferredStatusBarStyle方法)， 这个和UIView的setNeedsDisplay原理差不多(调用UIView对象的setNeedsDisplay方法后，系统会在下次页面刷新时，调用重绘该view，系统最快能1秒刷新60次页面，具体要看程序设置)。

- (UIViewController *)childViewControllerForStatusBarStyle:
这个接口也很重要，默认返回值为nil。当我们调用setNeedsStatusBarAppearanceUpdate时，系统会调用application.window的rootViewController的preferredStatusBarStyle方法，我们程序里一般都是用UINavigationController做root，如果是这种情况，那我们自己的UIViewController里的preferredStatusBarStyle根本不会被调用；这种情况下childViewControllerForStatusBarStyle就派上用场了，我们要子类化一个UINavigationController，在这个子类里面重写childViewControllerForStatusBarStyle方法，如下：

- (UIViewController *)childViewControllerForStatusBarStyle{
return self.topViewController;
}
上面代码的意思就是说，不要调用我自己(就是UINavigationController)的preferredStatusBarStyle方法，而是去调用navigationController.topViewController的preferredStatusBarStyle方法，这样写的话，就能保证当前显示的UIViewController的preferredStatusBarStyle方法能影响statusBar的前景部分。

另外，有时我们的当前显示的UIViewController可能有多个childViewController，重写当前UIViewController的childViewControllerForStatusBarStyle方法，让childViewController的preferredStatusBarStyle生效(当前UIViewController的preferredStatusBarStyle就不会被调用了)。

简单来说，只要UIViewController重写的的childViewControllerForStatusBarStyle方法返回值不是nil，那么，UIViewController的preferredStatusBarStyle方法就不会被系统调用，系统会调用childViewControllerForStatusBarStyle方法返回的UIViewController的preferredStatusBarStyle方法。

- (void)setNeedsStatusBarAppearanceUpdate:
让系统去调用application.window的rootViewController的preferredStatusBarStyle方法,如果rootViewController的childViewControllerForStatusBarStyle返回值不为nil，
则参考上面的讲解。

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
对于导航栏，基类仅仅提供newNavigationBar空的UIView，每个视图控制拥有的导航栏，自己添加;后期如果发现有公共的可以在基类中统一设置；

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
消除系统日志：if we're in the real pre-commit handler we can't actually add any new fences due to CA restriction
in your Xcode:
Click on your active scheme name right next to the Stop button
Click on Edit Scheme....
in Run (Debug)-->select the Arguments tab
in Environment Variables click +
add variable: OS_ACTIVITY_MODE = disable


//////////////////////////////////////////////////////////////////////////////////////////////////////////////





























































